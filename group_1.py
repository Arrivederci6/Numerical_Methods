# МЕТОД ХОРД

# Імпортуємо модуль numpy для роботи з числами
import numpy as np

# Визначаємо функцію, корінь якої шукаємо
def f(x):
    return x**3 + x + 3

# Визначаємо метод хорд, який приймає функцію, два початкових наближення, точність і максимальну кількість ітерацій
def chord_method(f, a, b, eps=1e-6, max_iter=1000):
    # Перевіряємо, що функція має різні знаки на кінцях інтервалу
    if f(a) * f(b) >= 0:
        raise ValueError("Функція повинна мати різні знаки на границях інтервалу")
    # Ініціалізуємо перше наближення кореня за формулою хорди
    x = a - (b - a) * f(a) / (f(b) - f(a))
    # Створюємо змінну для лічильника ітерацій
    count = 0
    # Повторюємо процес до тих пір, поки не досягнемо заданої точності або не перевищимо максимальну кількість ітерацій
    for _ in range(max_iter):
        # Збільшуємо лічильник на 1
        count += 1
        # Якщо значення функції в точці x дуже мале, то ми знайшли корінь
        if np.abs(f(x)) < eps:
            break
        # Якщо функція має однаковий знак з лівою границею, то змінюємо ліву границю на x
        if f(a) * f(x) < 0:
            b = x
        # Інакше змінюємо праву границю на x
        else:
            a = x
        # Обчислюємо нове наближення кореня за формулою хорди
        x = a - (b - a) * f(a) / (f(b) - f(a))
        # Перевіряємо, що хорда не дуже близько до 0
        if np.abs(b - a) < eps:
            # Якщо так, то збільшуємо відступ на 10%
            delta = (b - a) * 0.1
            a -= delta
            b += delta
            print("Хорда дуже близько до 0, збільшуємо відступ.")
    # Повертаємо знайдений корінь і кількість ітерацій
    return x, count

# Викликаємо метод хорд для нашої функції і заданих параметрів
root, count = chord_method(f, -3, 2)
# Виводимо результат на екран
print(f"Корінь рівняння: {root}")
print(f"Кількість ітерацій: {count}")
