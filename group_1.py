# Імпортуємо модуль numpy для роботи з числами
import numpy as np

# Визначаємо функцію, корінь якої шукаємо
def f(x):
    return x**3 + x + 3

# Визначаємо метод хорд, який приймає функцію, два початкових наближення, точність і максимальну кількість ітерацій
def chord_method(f, a, b, eps=1e-6, max_iter=1000):
    # Перевіряємо, що функція має різні знаки на кінцях інтервалу
    if f(a) * f(b) >= 0:
        raise ValueError("Функція повинна мати різні знаки на границях інтервалу")
    # Ініціалізуємо перше наближення кореня за формулою хорди
    x = a - (b - a) * f(a) / (f(b) - f(a))
    # Повторюємо процес до тих пір, поки не досягнемо заданої точності або не перевищимо максимальну кількість ітерацій
    for _ in range(max_iter):
        # Якщо значення функції в точці x дуже мале, то ми знайшли корінь
        if np.abs(f(x)) < eps:
            break
        # Якщо функція має однаковий знак з лівою границею, то змінюємо ліву границю на x
        if f(a) * f(x) < 0:
            b = x
        # Інакше змінюємо праву границю на x
        else:
            a = x
        # Обчислюємо нове наближення кореня за формулою хорди
        x = a - (b - a) * f(a) / (f(b) - f(a))
    # Повертаємо знайдений корінь
    return x

# Викликаємо метод хорд для нашої функції і заданих параметрів
root = chord_method(f, -3, 2)
# Виводимо результат на екран
print(f"Корінь рівняння: {root}")
