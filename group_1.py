import math
import numpy as np
from matplotlib import pyplot as plt

# Вхідні дані
Umax = 100  # Максимальна напруга джерела, В
f_eq = 50  # Частота джерела, Гц
R1 = 5  # Опір резистора R1, Ом
R2 = 4  # Опір резистора R2, Ом
R3 = 7  # Опір резистора R3, Ом
R4 = 2  # Опір резистора R4, Ом
L1 = 0.01  # Індуктивність котушки L1, Гн
L2 = 0.02  # Індуктивність котушки L2, Гн
L3 = 0.15  # Індуктивність котушки L3, Гн
C1 = 300e-6  # Ємність конденсатора C1, Ф
C2 = 150e-6  # Ємність конденсатора C2, Ф
C3 = 200e-6  # Ємність конденсатора C3, Ф
t_integration = 0.2  # Час інтегрування, с
h = 0.00001  # Крок інтегрування, с


def modified_euler_system(f, x0, t0, tn, h):
   # Функція, що реалізує метод Ейлера з модифікацією Хойна для системи диференціальних рівнянь
   # Приймає на вхід:
   # f - функція, що повертає вектор похідних від x за часом
   # x0 - початковий вектор x
   # t0 - початковий час
   # tn - кінцевий час
   # h - крок інтегрування
   # Повертає на вихід:
   # t_values - масив значень часу
   # x_values - масив значень x

   # Кількість кроків
   num_steps = int((tn - t0) / h)
   # Створюємо масив часу з рівномірним кроком h
   t_values = np.linspace(t0, tn, num_steps + 1)
   # Створюємо масив x з нульовими значеннями
   x_values = np.zeros((len(t_values), len(x0)))
   # Задаємо початкове значення x
   x_values[0] = x0

   # Ітеруємо по кроках
   for i in range(num_steps):
       # Поточне значення x
       x_prev = x_values[i]
       # Поточний час
       t = t_values[i]

       # Обчислюємо похідні за методом Ейлера
       k1 = h * f(x_prev, t)
       # Обчислюємо похідні за методом Ейлера з модифікацією Хойна
       k2 = h * f(x_prev + k1, t + h)
       # Обчислюємо наступне значення x за середнім значенням похідних
       x_values[i + 1] = x_prev + 0.5 * (k1 + k2)

   # Повертаємо масиви часу та x
   return t_values, x_values


def function(x, t):
   # Функція, що повертає вектор похідних від x за часом
   # Приймає на вхід:
   # x - вектор з трьох змінних: x[0] - напруга на конденсаторі C1, x[1] - напруга на конденсаторі C2, x[2] - струм через котушку L1
   # t - час
   # Повертає на вихід:
   # np.array([dxdt, dydt, dzdt]) - вектор з трьох похідних: dxdt - похідна x[0] за часом, dydt - похідна x[1] за часом, dzdt - похідна x[2] за часом

   # Система диференціальних рівнянь, що випливає з законів Кірхгофа для електричного кола
   dxdt = (Umax * math.sin(2 * math.pi * f_eq * t) - x[1] - x[0]) / (C1 * R1) # Похідна напруги на конденсаторі C1 за часом
   dydt = (Umax * math.sin(2 * math.pi * f_eq * t) - x[0] - x[1] - x[2] * R1) / (R1 * C2) # Похідна напруги на конденсаторі C2 за часом
   dzdt = (x[1] - x[2] * R2) / L1 # Похідна струму через котушку L1 за часом
   # Повертаємо вектор похідних
   return np.array([dxdt, dydt, dzdt])


x0 = np.array([0, 0, 0])  # Початковий вектор x, вважаємо, що на початку напруги на конденсаторах і струм через котушку дорівнюють нулю
t_values, x_values = modified_euler_system(function, x0, 0, t_integration, h) # Викликаємо функцію для чисельного розв'язку системи диференціальних рівнянь

u1_values = [Umax * math.sin(2 * math.pi * f_eq * t) for t in t_values] # Обчислюємо значення напруги U1 на джерелі змінного струму
u2_values = [R2 * elem for elem in x_values[:, 2]] # Обчислюємо значення напруги U2 на резисторі R2

plt.figure(figsize=(10, 6))
plt.plot(t_values, u1_values, label='U1')
plt.plot(t_values, u2_values, label='U2')
plt.xlabel('Time (t)')
plt.ylabel('Values')
plt.legend()
plt.title('System of Differential Equations')
plt.grid(True)
plt.show()

for t, x in zip(t_values, x_values):
   print(f"t = {t:.4f}, U1 = {Umax * math.sin(2 * math.pi * f_eq * t):.4f}, U2 = {R2 * x[2]:.4f}")
