# Імпортуємо модуль numpy для роботи з числами
import numpy as np

# Визначаємо функцію, корінь якої шукаємо
def f(x):
    return x**3 + x + 3

# Визначаємо метод поділу ділянки навпіл, який приймає функцію, два початкових наближення, точність і максимальну кількість ітерацій
def bisection_method(f, a, b, eps=1e-6, max_iter=1000):
    # Перевіряємо, що функція має різні знаки на кінцях інтервалу
    if f(a) * f(b) >= 0:
        raise ValueError("Функція повинна мати різні знаки на границях інтервалу")
    # Ініціалізуємо середину інтервалу
    c = (a + b) / 2
    # Повторюємо процес до тих пір, поки не досягнемо заданої точності або не перевищимо максимальну кількість ітерацій
    for _ in range(max_iter):
        # Якщо значення функції в точці c дуже мале, то ми знайшли корінь
        if np.abs(f(c)) < eps:
            break
        # Якщо функція має однаковий знак з лівою границею, то змінюємо ліву границю на c
        if f(a) * f(c) < 0:
            b = c
        # Інакше змінюємо праву границю на c
        else:
            a = c
        # Обчислюємо нову середину інтервалу
        c = (a + b) / 2
    # Повертаємо знайдений корінь
    return c

# Викликаємо метод поділу ділянки навпіл для нашої функції і заданих параметрів
root = bisection_method(f, -3, 2)
# Виводимо результат на екран
print(f"Корінь рівняння: {root}")
