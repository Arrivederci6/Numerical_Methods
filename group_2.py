# МЕТОД ПОДІЛУ ДІЛЯНКИ НАВПІЛ З ПОШУКОМ ДІЛЯНКИ ЛОКАЛІЗАЦІЇ

import numpy as np

# Визначаємо функцію, корінь якої шукаємо
def f(x):
    return x**3 + x + 3

# Визначаємо похідну функції
def df(x):
    return 3*x**2 + 1

# Визначаємо метод поділу ділянки навпіл з пошуком ділянки локалізації, який приймає функцію, похідну, два початкових наближення, точність і максимальну кількість ітерацій
def bisection_newton_method(f, df, a, b, eps=1e-6, max_iter=1000):
    # Перевіряємо, що функція має різні знаки на кінцях інтервалу
    if f(a) * f(b) >= 0:
        raise ValueError("Функція повинна мати різні знаки на границях інтервалу")
    # Ініціалізуємо середину інтервалу
    c = (a + b) / 2
    count = 0
    # Повторюємо процес до тих пір, поки не досягнемо заданої точності або не перевищимо максимальну кількість ітерацій
    for _ in range(max_iter):
        count += 1
        # Якщо значення функції в точці c дуже мале, то ми знайшли корінь
        if np.abs(f(c)) < eps:
            break
        # Якщо функція має однаковий знак з лівою границею, то змінюємо ліву границю на c
        if f(a) * f(c) < 0:
            b = c
        # Інакше змінюємо праву границю на c
        else:
            a = c
        # Застосовуємо метод Ньютона на відрізку [a, b]
        x = c - f(c) / df(c) # Нове наближення за формулою Ньютона
        # Якщо нове наближення належить відрізку [a, b], то приймаємо його
        if a <= x <= b:
            c = x
        # Якщо нове наближення не належить відрізку [a, b], то відкидаємо його і продовжуємо метод бісекції
        else:
            pass
    # Повертаємо знайдений корінь і кількість ітерацій
    return c, count

# Викликаємо метод поділу ділянки навпіл з пошуком ділянки локалізації для нашої функції і заданих параметрів
root, count = bisection_newton_method(f, df, -3, 2)
# Виводимо результат на екран
print(f"Корінь функції: {root}")
print(f"Кількість ітерацій: {count}")
