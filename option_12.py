import matplotlib.pyplot as plt

R1 = 11  # Опір резистора R1, Ом
R2 = 22  # Опір резистора R2, Ом
R3 = 33  # Опір резистора R3, Ом
C1 = 34  # Ємність конденсатора C1, мФ
C2 = 26  # Ємність конденсатора C2, мФ
L_min = 0.83  # Мінімальна індуктивність котушки L2, Гн
L_max = 8.3  # Максимальна індуктивність котушки L2, Гн
i_min = 1  # Мінімальний струм через котушку L2, A
i_max = 2  # Максимальний струм через котушку L2, A


# Алгоритм методу Рунге-Кутта для системи
def runge_kutta_system(x0, y0, x_end, h):
   # Функція, що реалізує метод Рунге-Кутта четвертого порядку для системи диференціальних рівнянь
   # Приймає на вхід:
   # x0 - початковий час
   # y0 - початковий вектор y, який складається з трьох змінних: y[0] - напруга на конденсаторі C1, y[1] - струм через котушку L2, y[2] - напруга на конденсаторі C2
   # x_end - кінцевий час
   # h - крок інтегрування
   # Повертає на вихід:
   # x_values - масив значень часу
   # U_C1_values - масив значень напруги на конденсаторі C1
   # i_3_values - масив значень струму через котушку L2
   # U_C2_values - масив значень напруги на конденсаторі C2
   x_values = [] # Створюємо порожній масив для значень часу
   U_C1_values = [] # Створюємо порожній масив для значень напруги на конденсаторі C1
   i_3_values = [] # Створюємо порожній масив для значень струму через котушку L2
   U_C2_values = [] # Створюємо порожній масив для значень напруги на конденсаторі C2
   x = x0 # Задаємо початкове значення часу
   y1, y2, y3 = y0 # Задаємо початкові значення для y1, y2, y3
   while x < x_end: # Поки час не досягне кінцевого значення
       x_values.append(x) # Додаємо поточне значення часу до масиву
       U_C1_values.append(y1) # Додаємо поточне значення напруги на конденсаторі C1 до масиву
       i_3_values.append(y2) # Додаємо поточне значення струму через котушку L2 до масиву
       U_C2_values.append(y3) # Додаємо поточне значення напруги на конденсаторі C2 до масиву
       # Обчислюємо похідні за методом Рунге-Кутта
       k1 = h * f1(x, y1, y2, y3) # Перший коефіцієнт для y1
       l1 = h * f2(x, y1, y2, y3) # Перший коефіцієнт для y2
       m1 = h * f3(x, y1, y2, y3) # Перший коефіцієнт для y3
       k2 = h * f1(x + h / 3, y1 + k1 / 3, y2 + l1 / 3, y3 + m1 / 3) # Другий коефіцієнт для y1
       l2 = h * f2(x + h / 3, y1 + k1 / 3, y2 + l1 / 3, y3 + m1 / 3) # Другий коефіцієнт для y2
       m2 = h * f3(x + h / 3, y1 + k1 / 3, y2 + l1 / 3, y3 + m1 / 3) # Другий коефіцієнт для y3
       k3 = h * f1(x + h * 2 / 3, y1 + 2 * k2 / 3, y2 + 2 * l2 / 3, y3 + 2 * m2 / 3) # Третій коефіцієнт для y1
       l3 = h * f2(x + h * 2 / 3, y1 + 2 * k2 / 3, y2 + 2 * l2 / 3, y3 + 2 * m2 / 3) # Третій коефіцієнт для y2
       m3 = h * f3(x + h * 2 / 3, y1 + 2 * k2 / 3, y2 + 2 * l2 / 3, y3 + 2 * m2 / 3) # Третій коефіцієнт для y3
       # Обчислюємо наступні значення для y1, y2, y3 за середнім значенням похідних
       y1 = y1 + (k1 + 3 * k3) / 4 # Наступне значення для y1
       y2 = y2 + (l1 + 3 * l3) / 4 # Наступне значення для y2
       y3 = y3 + (m1 + 3 * m3) / 4 # Наступне значення для y3
       x = x + h # Збільшуємо час на крок інтегрування
   # Повертаємо масиви значень часу, напруги на конденсаторах та струму через котушку
   return x_values, U_C1_values, i_3_values, U_C2_values

# Функції, які описують систему диференціальних рівнянь
def u1(x):
   # Функція, що повертає значення напруги U1 на джерелі змінного струму в залежності від часу
   # Приймає на вхід:
   # x - час
   # Повертає на вихід:
   # 10 - якщо час належить першій половині періоду
   # -(x % (2 * a)) * 10 / a + 10 - якщо час належить другій половині періоду
   a = 0.003 # Половина періоду джерела, с
   if x % (2 * a) <= a: # Якщо час належить першій половині періоду
       return 10 # Повертаємо максимальне значення напруги, В
   else: # Якщо час належить другій половині періоду
       return (-(x % (2 * a)) * 10 / a + 10) # Повертаємо значення напруги, що зменшується лінійно, В


def L2(i_3):
   # Функція, що повертає значення індуктивності L2 в залежності від струму i_3
   # Приймає на вхід:
   # i_3 - струм через котушку L2, A
   # Повертає на вихід:
   # 15 - якщо модуль струму не перевищує 1 A
   # a0 + a1 * (abs(i_3)) + a2 * (abs(i_3) ** 2) + a3 *(abs(i_3) ** 3) - якщо модуль струму належить інтервалу (1, 2) A
   # 1.5 - якщо модуль струму перевищує 2 A
   # Коефіцієнти a0, a1, a2, a3 обчислюються за даними L_min, L_max, i_min, i_max
   a0 = (L_min * i_max ** 2 - L_min * i_min ** 2 - L_max *
         i_max ** 2 + L_max * i_min ** 2) / (i_max ** 2 - i_min ** 2) # Коефіцієнт a0
   a1 = a0 + R1 * i_min # Коефіцієнт a1
   a2 = a0 + R1 * i_max # Коефіцієнт a2
   a3 = a0 + R2 * i_max # Коефіцієнт a3
   if abs(i_3) <= 1: # Якщо модуль струму не перевищує 1 A
       return 15 # Повертаємо мінімальне значення індуктивності, Гн
   elif abs(i_3) <= 2: # Якщо модуль струму належить інтервалу (1, 2) A
       return a0 + a1 * (abs(i_3)) + a2 * (abs(i_3) ** 2) + a3 *(abs(i_3) ** 3) # Повертаємо значення індуктивності, що зростає кубічно, Гн
   else: # Якщо модуль струму перевищує 2 A
       return 1.5 # Повертаємо максимальне значення індуктивності, Гн


def f1(t, U_C1, i_3, U_C2):
   # Функція, що повертає похідну напруги на конденсаторі C1 за часом
   # Приймає на вхід:
   # t - час
   # U_C1 - напруга на конденсаторі C1, В
   # i_3 - струм через котушку L2, A
   # U_C2 - напруга на конденсаторі C2, В
   # Повертає на вихід:
   # (u1(t) - U_C1 - U_C2) * 10 ** 3 / (R1 * C1) - похідна напруги на конденсаторі C1 за часом, В/с
   return (u1(t) - U_C1 - U_C2) * 10 ** 3 / (R1 * C1) # За законом Кірхгофа для першої петлі


def f2(t, U_C1, i_3, U_C2):
   # Функція, що повертає похідну струму через котушку L2 за часом
   # Приймає на вхід:
   # t - час
   # U_C1 - напруга на конденсаторі C1, В
   # i_3 - струм через котушку L2, A
   # U_C2 - напруга на конденсаторі C2, В
   # Повертає на вихід:
   # (U_C2 - i_3 * (R2 + R3)) / L2(i_3) - похідна струму через котушку L2 за часом, А/с
   return (U_C2 - i_3 * (R2 + R3)) / L2(i_3) # За законом Кірхгофа для другої петлі


def f3(t, U_C1, i_3, U_C2):
   # Функція, що повертає похідну напруги на конденсаторі C2 за часом
   # Приймає на вхід:
   # t - час
   # U_C1 - напруга на конденсаторі C1, В
   # i_3 - струм через котушку L2, A
   # U_C2 - напруга на конденсаторі C2, В
   # Повертає на вихід:
   # (u1(t) - U_C1 - U_C2 - R1 * i_3) * 10 ** 3 / (R1 * C2) - похідна напруги на конденсаторі C2 за часом, В/с
   return (u1(t) - U_C1 - U_C2 - R1 * i_3) * 10 ** 3 / (R1 * C2) # За законом Кірхгофа для третьої петлі

# Початкові дані
x0 = 0
y0 = [1, 0, 0]  # Початкові значення для y1, y2, y3
x_end = 0.03  # Закінчення обчислень (5 періодів по 0.006 секунд)
h = 0.000015  # Початковий крок інтегрування (T / 400)
x_values, U_C1_values, i_3_values, U_C2_values = runge_kutta_system(x0, y0, x_end, h)

# Збереження результатів у файл
with open("result.dat", "w") as file:
   for t, U_C1, i_3, U_C2 in zip(x_values, U_C1_values,
i_3_values, U_C2_values): file.write(f"time = {t}, "
f"voltage across the capacitor c1 = {U_C1}, "
f"current in the inductor = {i_3}, "
f"voltage across the capacitor c2 = {U_C2},"
f"voltage u2 ={50 * U_C2},"
f"inductance l2={L2(i_3)},"
f"voltage u1={u1(t)}\n")

# Початок графіку
plt.figure(figsize=(12, 8))
plt.subplot(3, 2, 1)
plt.plot(x_values, U_C1_values)
plt.title("Voltage on the capacitor 1 (y1)")
plt.xlabel("Time")
plt.ylabel("Value")
plt.subplot(3, 2, 2)
plt.plot(x_values, i_3_values)
plt.title("Current in the inductance (y2)")
plt.xlabel("Time")
plt.ylabel("Value")
plt.subplot(3, 2, 3)
plt.plot(x_values, U_C2_values)
plt.title("Voltage on the capacitor 2 (y3)")
plt.xlabel("Time")
plt.ylabel("Value")
plt.subplot(3, 2, 4)
plt.plot(x_values, [elem * 50 for elem in U_C2_values])
plt.title("Voltage U2 (50*y3)")
plt.xlabel("Time")
plt.ylabel("Value")
plt.subplot(3, 2, 5)
plt.plot(x_values, [u1(elem) for elem in x_values])
plt.title("Voltage U1 (x)")
plt.xlabel("Time")
plt.ylabel("Value")
plt.tight_layout()
plt.show()
